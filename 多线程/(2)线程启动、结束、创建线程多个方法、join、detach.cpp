#include<iostream>
#include<thread>

using namespace std;

//自己创建的线程也要从一个函数(初始函数)开始运行：
void  myprint() {

	cout << "我的线程开始执行了" << endl;

	cout << "我的线程执行完毕 " << endl;
}

class TA {
public:
	int m_i;//int& m_i;   //调用detach()时主线程的局部变量可能被释放，从而可能会导致不可预料的后果
	TA(int i) :m_i(i){
		cout << "TA()构造函数被执行" << endl;
	}
	TA(const TA& ta) :m_i(ta.m_i) {   //拷贝函数会被调用，class对象实际上是被赋值到子线程里面去的，所以会调用拷贝构造函数
		cout << "TA()拷贝构造函数被执行" << endl;
	}
	~TA() {
		cout << "~TA()析构函数被执行" << endl;  //析构函数会被调用两次，因为是拷贝到子线程里面的
												//子线程结束时会释放一次，主线程结束时会调用一次
	}
	void operator ()() //不能带参数
	{
		/*cout << "我的线程operator()开始执行了" << endl;
		cout << "我的线程operator()结束执行了" << endl;*/
		cout << "m_i1的值为：" << m_i << endl;   //产生不可预料的结果
		cout << "m_i2的值为：" << m_i << endl;
		cout << "m_i3的值为：" << m_i << endl;
		cout << "m_i4的值为：" << m_i << endl;
	}
};
int main() {
	//一：范例演示运行的开始和结束
	//程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；

	//cout << "I Love China" << endl;   //实际上这个是主线程在运行，主线程从main（）函数返回，则整个进程执行完毕。

	//主线程从main函数开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数）。
	//一旦函数运行完毕，代表着我们这个线程运行结束

	//整个进程是否执行完毕的标志是主线程是否执行完毕，如果主线程执行完毕了，就代表整个进程执行完毕了；
	//此时，一般情况下：如果其他子线程还没有执行完毕，那么这些子线程也会被操作系统强制终止
	//一般情况下：如果想保持子线程（代码创建的线程）的运行状态，那么就要让主线程一直保持运行，不让主线程执行完毕
	//[这条规律有例外]

	//a）包含一个thread头文件
	//b)初始函数要写。
	//c)main中开始写代码
	//必须明确一点：有两个线程再跑，相当整个程序的执行有两条线同时在走，可以同时干两个事。
	//即使一条线被堵住了，另外一条线还是可以通行的。

	//（1.1）thread：是个标准库里的类

	// (1.2) join():  加入/汇合  ,阻塞主线程，让主线程等待子线程执行完毕，然后子线程和主线程汇合，然后主线程再往下走
	//如果主线程执行完毕了，但子线程没执行完毕，写出来的程序是不稳定的
	//一个书写良好的程序，应该是主线程等待子线程执行完毕后，自己才能最总退出。

	//(1.3)detach():传统多线程程序主线程要等待子线程执行完毕，然后自己最后退出；
	//detach:分离，也就是主线程不和子线程汇合了，主线程执行主线程，子线程执行子线程，互不干扰。
	//为什么引入detach()?：假如创建了很多子线程，让主线程逐个等待子线程结束，这种编程方法不太好，所以引入了detach();
	//一旦detach()之后，与主线程关联的thread对象就会失去与这个主线程的关联，此时这个子线程就会驻留的后台运行（主线程跟该子线程失去联系）
	//这个子线程就相当于被c++运行时库所接管，当这个子线程执行完毕后，由运行时库负责清理该线程相关的资源（守护线程）。
	//detach()使线程myprint失去我们自己的控制。

	//(1.4)joinable（）:判断是否可以成功使用join()或者detach()的；返回true或者false
	//myprint是个课调用对象
	thread myobj(myprint);   //（1）创建了线程，形成执行起点（入口）myprint（）；（2）myprint线程开始执行
	if (myobj.joinable()) {
		cout << "1:joinable() == true" << endl;
	}
	else {
		cout << "1:joinable() == false" << endl;
	}
	//阻塞主线程等待myprint子线程执行完毕
	//myobj.join();   //主线程阻塞到这里等待myprint（）执行完，当子线程执行完毕，这个join（）就执行完毕，主线程就继续往下走
	myobj.detach();  //一旦调用了detach()，就不能再用join（），否则系统会报告异常
	if (myobj.joinable()) {
		cout << "1:joinable() == true" << endl;
	}
	else {
		cout << "1:joinable() == false" << endl;
	}
	cout << "主线程收尾，最终主线程安全退出" << endl;


	//二：其他创建线程的手段
	//(2.1)用类对象（可调用对象），来创建可调用对象
	//大家可能还有一个疑问：一旦调用了detach()，那主线程执行结束了，这里用的这个ta这个对象还在吗？（对象不再没关系）
	//这个对象实际上是被复制到线程中去；执行完主线程后，ta会被销毁，但是所复制的TA 对象任然存在。
	//所以，还要你这个TA对象里没有引用，没有指针，那么就不会产生问题。

	int myi = 6;
	TA ta(myi);
	thread mytobj3(ta);  //ta可调用对象
	mytobj3.join();   //等待子线程执行结束

	//mytobj3.detach();

	//(2.2)用lambda表达式
	auto mylamthread = [] {
		cout << "我的线程3开始执行了" << endl;

		cout << "我的线程3执行结束了" << endl;
	};

	thread myobj4(mylamthread);
	myobj4.join();
	return 0;
}