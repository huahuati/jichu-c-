
#include : 预编译命令，作用就是将某些文件包含到用户的源文件中。
标准的I/O库：stdio.h叫头文件(head)
#include<stdio.h>  //<>是去系统目录中找头文件，所以像标准的stdio.h头文件就用<>
#include "stdio.h"  // ""的含义是首先在当前目录中查找，如果找不到，再到系统目录中查找。""用于自己写的头文件
                            //让系统优先使用当前目录中定义的头文件

数据的输入：从键盘上输入数据
a)    
    char a;
    a = 'A'
    putchar(a);  // 输出一个字符
b) getchar():执行后等待用户从键盘上输入一个字符，并按回车后程序才能执行。
    char c;
    c = getchar(); 
    putchar(c);
c) scanf函数，格式化输入函数，用来输入任何类型的函数
    int a,b,c;
    scanf("%d%d%d",&a,&b,&c); //三个输入的数字 之家可以用 空格，回车，tab分隔，但不能用逗号分隔。
    scanf("%d，%d，%d",&a,&b,&c); //三个输入的数字 必须假如逗号。

逻辑判断：
在C语言中，“真”用ture表示，也可以用1表示，“假”用false表示，也可以用0表示。
    if(ture==1)
    {
        printf("ture==1\n");  //为真
    }

    分析
    a=3,b=2,c=1;
    (a>b) ==c  ===> ture == c ===>ture;

条件运算符：
    int a=4,b=5,max;
    max = (a > b)?a:b   //如果 a>b的值为真，则条件表达式取a的值作为整个值，否则取b作为整个值    
    条件运算符有三个操作对象，也叫三目运算符，它是C语言中唯一一个三目运算符。
    一般形式：
        表达式1？表达式2：表达式3
    max = a > b?a:b   条件运算符优先级比关系运算符低

    因为条件运算符的结合顺序是从右到左的，所以：
        a>b ? a:c>d?c:d ===>  a>b ? a:(c>d ? c:d)

switch语句：
    格式：
        switch(表达式)
        {
            case 常量表达式1：
                {}
                break;
            case 常量表达式2：
                {}
                break;
                ...
            case 常量表达式n：
                {}
                break;
            default:
                {}
                break;
        }
    说明：
    //switch后面表达式一般都是整形变量或者表达式，其他类型也允许，但是都很罕见。
    //每个case后面的常量表达式必须互不相等，不然会出现编译错误。
    //各个case语句之间，case和default语句之间，顺序没有影响，谁在上边，谁在下边，都无所谓
    //绝对不能忘记break语句。

循环结构：goto
    一般格式：
        goto 语句标号：  其中语句标号是一个标识符（只能由字母，数字，下划线三种字符组成，且第一个字符必须是字母或者下划线）
                            并且，标识符不可以是系统的保留字.
        goto语句主要的用途：
            1)与if语句一起构成循环结构
            2)从循环体内跳转到循环体外。  不推荐使用，破话了结构化程序设计原则，除非万不得已。
做个从1到100的加法运算，用goto与来实现
    int i = 1, sum = 0;
loop:
    if(i<=100)
    {
        sum = sum + i;
        i++;
        goto loop;
    }
//目前goto语句引用场合很少，非必要不使用。


for语句
 for(表达式1;表达式2;表达式3)
    //(1)表达式1可以省略，但其后边的分号不能省略，当表达式1省略时，应该在for之前给循环变量赋予初值。
    //(2)表达式2可以省略，但器后边的分号不能省略，也就是不判断循环条件，那么循环就会无终止的执行下去了，此时，就必须用break语句终止循环
    //(3)表达式3可以省略，也要想办法终止循环。
    //(4)可以省略表达式1，表达式3，只保留表达式2。
    //(5)单个表达式都可以省略；不设置初值，不判断条件，循环变量不增加。
            for(;;)   ===>  while(1)

    //(6)表达式1可以设置循环变量初值，也可以是与循环变量无关的其他表达式；
        int i, sum;
        i = 1;
        for(sum=0;i<=100;i++)
        {
            sum = sum + i;
        }
    //(7)表达式1和表达式3都可以使简单的表达式或者逗号表达式
            注意：表达式1只会被执行一次，但是表达式3会被执行多次。
    //总结：虽然for语句有可能有多种发梢的用法，但是要规矩使用。

数组注意事项：
    int a[10];   //能引用的就是a[0] ~ a[9];
    a[10] = 8;   //这是致命的错误
    注意：常量表达式中，可以是常量表达式，但不能包含变量；也就是说，c语言不允许对数组的大小做动态定义

    一位数组的初始化
    int a[10];   //不给值
    int a[10] = {1,2,3,4,5,6,7,8,9,10}; //赋予十个初值
    int a[10] = {1,2,3,4,5}  //只给一部分元素赋值，小于10个数字，其他元素系统自动给了0；

    可以不指定数组长度
    int a[] = {1,2,3,4,5}；  //在定义数组时，当[]里没有数字时，系统会猜测这个数组赋初值这个语句里边有多少个值。
                                //有多少个值，这个数组的长度就是多少，

    二维数组的初始化
    a)分行给二维数组赋初值
    int a[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12}};
    b)将所有数组放在一个大括号里
    int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
    int b[][4] = {1,2,3,4,5,6,7,8,9,10,11,12};  //第一维可以省略，第二位不可以省
    c)对部分元素赋初值
    int c[3][4] = {{1},{3,4}};
    int d[3][4] = {{1},{},{9}};

    d)
    int e[][4] = {{0,0,3},{},{0,10}};

字符数组：用来存放字符数据的数组。字符数组中的一个元素村发放一个字符
    char c[10];
    
    字符数组的初始化:
    逐个字符赋给数组中的元素
    1)char c[10] = {'I',' ,','a','m','h','a','p','p','y'};

    2)如果提供的初值个数和预订的数组长度相同，定义时可以省略数组长度，系统会自动根据初值个数确定数组长度。
    char c[] = {'I',' ,','a','m','h','a','p','p','y'}; 

    3)初值个数 < 数组长度，则只将这些字符赋值给数组中前面那些元素，其余的元素值可能会给\0，也可能无法确定，不建议使用
    char c[12] = {'I',' ,','a','m','h','a','p','p','y'};
    上述初始化相当于
    c[10]=0;
    c[11]=0;

    char diamond[3][3] = {{'','*',''},{'*','','*'},{'','*',''}};

    字符串和字符串结束标记 ***重点
    用字符串常量来初始化字符数组
    char d[] = {"I am happy"}; //系统会自动在字符串末尾增加一个\0,作为结束标记
                                //如果一个字符串，他的第10个字符为'\0',则此字符串的有效长度为9个
    char *p = "I am happy";

    char c[10] = {'I',' ,','a','m','h','a','p','p','y','\0'}; //等价于下面
    char d[] = {"I am happy"};  //字符串末尾会自动增加一个'\0'

    char c[] = "China";
    printf("%s\n",c);    //%s格式用来输出一个字符数组（字符串）
        1)printf输出的字符不包括 \0 (字符串结束标记)
        2)%s对应的是字符数组名c
        3)即便数组长度大于字符串实际长度，也只输出的\0结束。
        4)如果一个字符数组里包含多个\0，printf遇到第一个也就结束。
    
    从键盘输入一个字符串，用scanf来完成
    char c[100];
    scanf("%s",c);  //从键盘输入一个字符串，c：字符数组名
    printf("%s\n",c);

    char str1[10],str2[10],str3[10];
    scanf("%s%s%s",str1,str2,str3); 

    char str[100];
    scanf("%s",str);  //输入一个字符串的时候不能假如空格，否则空格后的内容会被丢弃
                        //str这个字符数组名本身就代表该数组的起始地址
                        //str 和 &str 被等同看待，都被认为是数组的起始地址。
    printf("%d\n",str);  //用10进制整数形式打印数组的起始地址
    printf("%d\n",&str);  //用10进制整数形式打印数组的起始地址

    强调:在c语言中，以为字符数组就看成字符串变量

字符串处理函数：
    1)puts(字符串数组):将一个字符串输出到屏幕(能换行)，注意只能输出一个字符串
        char str[100] = "Are you ok?";
        puts(str);
    
    2)gets(字符数组名)：从键盘输入一个字符串到字符数组中，只能输入一个字符串。
        char str[100];
        gets(str);
        printf("%s\n",str);

    3)strcat(字符数组1，字符数组2)   比较常用，的掌握 [需要包含 #include<string.h>头文件]
            //连接两个字符数组中的字符串，把字符串2连接到字符串1后面，结果放在字符数组中。
        说明：
            1)字符数组1必须足够大，能够容纳连接后的新字符串
            2)连接之前两个字符串后面都有一个\0，连接时将字符串1后边的\0取消，连接后只在新串最后保留一个\0; 
        char str1[10] = "one";
        char str2[10] = "two";
        strcat(str1,str2);

    4)strcpy(字符数组1,字符串2)，常用函数，需要掌握
            //将字符串2拷贝到字符数组1中去。字符数组1中的内容将被覆盖
        说明：
            1)字符数组1必须足够大，必须大到可以容纳2的程度
            2)字符数组1必须是个数组名，字符串2可以是个数组名字，也可以是个字符串常量
            3)拷贝的时候是连同字符串后边的\0也一起拷贝到字符数组中去了。
            4)不能用赋值语句将一个字符串常量或者字符数组直接赋给一个字符数组。

        char str1[10] = "one1234";   //定义的时候初始化 
        char str2[15] = "two"
        strcpy(str1,str2);  //str1的大小，一定不要小于str2
 
        赋值语句只能将一个字符赋值给一个字符型变量或者数组元素
        str1 = "China";    //赋值语句   这样赋值时错误的

    5)strcmp(字符串1，字符串2)  //比较字符串1和字符串2，也算一个常用函数
        说明：
            1)如果字符串1等于字符串2，该函数返回0；
            2)如果字符串1  > 字符串2 ，返回一个正整数 > 0 的数  1
            3)如果字符串2  < 字符串2，返回一个负整数  < 0 的数 -1
            4)常用于比较 相等或者不相等。一般不用于比较大小。
        
        if(str1 == str2)  //如果这样比的话就是比地址了。
        if(strcmp(str1,str2) == 0) //内容比较
    
    6)strlen(字符数组) ********重点函数
            //测试字符串长度的函数，函数的值是字符串的实际长度，但不包括\0
        char str1[120] = "open1";
        int len1 = strlen(str1);

函数：
    1)把函数全部放在main函数上面
    2)函数不能嵌套，不要手工去调用main()，这个是留给系统调用的。
    3)函数分两类
        1.1)库函数，比如printf：直接使用，不需要我们自己定义。strcpy，strcmp，strlen
        1.2)自定义函数
    4)函数声明
        把函数声明放在任何源代码文件的具体函数之前，才能保证这些具体的函数，调用其他函数时，这些被调用的函数时声明过的函数
            函数声明的一般形式：
            类型标识符 函数名 (形参形式);
            例如:void printhello();
    5)函数的嵌套调用
        c语言中不允许在一个函数中定义另外一个函数(也就是说，不允许函数的嵌套定义)

数组作为实参：
    C语言规定，实参变量对形参变量的数据传递是 “值传递”，也是单向传递，只有实参传递给形参，不能由形参传递给实参。形参并不分配内存。
    数组名代表的是数组的首地址，此时，函数中的形参也应该用数组名。
    注意：数组名作为函数参数时，不是“值传递”的概念了，而是把实参数组的开始地址传递给了形参数组。
                这样两个数组就会共用一段内存。称其为地址传递，值传递的时候，需要分配内存。
    说明：  
         1)如果实参为数组名，则形参也为数组名
         2)形参数组与实参数组类型要一致，比如都要为int型，否则会出现意想不到的错误
         3)形参数组大小可以不指定，即便指定了也可以与实参数组大小不一致，因为C编译器对形参数组大小不做检查，
                只是将实参的首地址传递给形参数组。
    多维数组作为函数实参：(也是地址传递)
        1)参数数组在定义时，可以指定每一维的大小，也可以省略一维大小，但不能省略二维大小。
        2)实参是这些行列，形参就要尽量跟实参一样，这样实参能引用的下标形参就可以引用。 


局部变量和全局变量：
    局部变量：
        int a,b;
        用大括号写一段代码段；大括号括起来的这个叫复合语句，在该复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也叫作程序块 
    全局变量:在函数外定义的变量称为全局变量(外部变量)
    全局变量  可以为本文件中其他函数所共有，全局变量的有效范围:从定义变量的位置开始到本程序文件结束。
                如果在整个文件开头定义了该变量，则整个文件范围内都可以使用该全局变量。
        总结：在一个函数中，既可以使用本函数中的局部变量，又可以使用有效的全局变量。

    优点：增加了函数与函数之间的数据联系渠道。如果一个函数中改变了全局变量的值，就能够影响其他函数，相当于在各个函数之间有了直接的传递通道，
                    不再需要通过实参和形参来传递参数值了
    缺点：              
        1)只有在必要的时候才使用全局变量,因为全局变量在程序运行的整个周期都占用内存，而不像函数内的局部变量，函数内局部变量的特点是当函数执行完毕后，
                这些局部变量所占的内存会被系统回收。
        2)降低了函数的通用性，因为函数执行时要依赖这些外部的全局变量了；如果将函数迁移到另外一个文件中，那这些相关的外部变量就得跟着移植过去，
                并且如果迁移到另外一个文件中也有同名全部变量，那更麻烦。
        3)东一个全部变量，西一个全部变量，降低了程序的清晰性和可读性。读程序的人难以清除的判断每个瞬间各个外部变量的值
    
        说明：
            (1)如果某个函数想引用在他后面定义的全局变量，则可以用一个关键字叫extern做一个“外部变量说明”，
                //表示该变量在函数的外部定义，这样函数内就能使用，否则编译就会出错。
              所以，结论是 全局变量的定义放在引用它的所有函数之前，就可以避免使用这个extern
            (2)要严格区分外部变量定义和外部变量声明：
                外部变量定义只能有一次，位置是所有函数之外，定义时会分配内存，定义时可以初始化值。
                而同一个文件中，外部变量说明可以有很多次的（外部变量说明不分配内存），也可只在函数内部声明，可以在不同的函数中声明多次。
            extern int a,b;  //外部变量声明
            int a,b;  //后面必须要有定义，并且只能有一次
            (3)在同一个源文件中，如果全局变量和局部变量同名，则在局部变量作用范围内，全局变量不起作用（当然值也不会受影响）

变量的存储类别：
    从变量存在的时间（生存期）角度来划分，可以把变量划分为：静态存储变量和动态存储变量。从而引出 静态存储方式 和 动态存储方式
        静态存储变量：在程序运行期间分配固定存储空间的变量。（静态存储方式）
        动态存储变量：在程序运行期间根据需要进行动态分配存储空间的变量 （动态存储方式）

        全局变量（在函数外部定义）放在静态存储区中，程序开始执行的时候给全局变量分配存储区，程序执行完毕后释放这些存储区。
            在程序执行过程中他们占据着固定的存储单元，而不是动态的分配和释放

        动态存储区中存放着那些数据？？
            1)函数形参。函数形参被看做是局部变量。
            2)局部变量，比如函数内定义的一些变量。
            3)函数调用时现场的一些数据和放回地址等。
        一般来讲，这些数据在函数调用开始时分配存储空间，函数调用完毕，这些空间就被释放掉了。这种分配和释放，就是动态的。
            两次调用同一个函数，分配给词函数的局部变量等等的存储空间地址可能就是不同的。
    
局部变量的存储方式
    1)传统方式:
        函数的局部变量：函数调用时分配存储空间，函数执行完成后自动释放其所占用的存储空间
    2)特殊情形:
        局部静态变量:用static加以说明：能够保留原值，占用的存储单元不释放。在下一次调用该函数时，该变量的值，就是上一次该函数调用结束时的值

    局部静态变量说明：
        1)在静态存储区内分配存储单元，程序整个运行期间不释放。
        2)局部静态变量是在编译时赋予初值的，只赋予初值一次，在程序运行时，就已经有初值了。
                以后每次调用函数时不再重新赋予初值，而是保留上次函数调用结束时的值
        3)定义局部静态变量时，如果不赋予初值，则编译时自动赋予初值0，而普通的局部变量，如果不赋初值，则该普通局部变量是一个不确定的值。
        4)虽然局部静态变量在函数调用结束后仍然存在，但其他函数是不能引用它的。
        5)缺点:长期占用内存，降低函数的可读性。
        结论：除非必要，否则不要多用局部静态变量

全部变量跨文件使用
    extern  做一个外部变量说明
    在引用该全局变量的文件中的头部做一个“外部文件说明”就可以。说明该变量存在其他文件中定义过，本文件不必在为它分配内存
        extern int g_a;  //对外部全局变量说明，必须要放在文件的开头

    在定义全局变量时增加static，则该全局变量只能在本文件中使用。

函数的跨文件调用：
    根据函数能够被其他文件调用，将函数分为内部函数和外部函数
    内部函数：只能被本文件中其他函数调用。定义内部函数的时候，在函数定义最前边加一个static，形式如下：
        static 类型标识符 函数名（形参名）  {...}

     内部函数又称为“静态函数”：使用内部函数，可以使函数只局限于所在文件。
     外部函数：如果一个函数定义，不用static，他就是外部函数。在其前面添加extern,但默认就是extern。
        调用其他文件中的函数时，要在本文件中进行函数声明！

static用法总结：
    (1)函数内部定义一个变量的时候使用static，则该变量会保存在静态存储区，在编译的时候被初始化，不初始化值，则它的值会被初始化为0
                下次调用该函数时该变量保持上次离开该函数时的值。
    (2)在全部变量之前增加static，会导致该全局变量只能被本文件引用，无法再其他文件中引用。
    (3)在函数定义之前增加static, 那么会导致该函数只能在本文件中调用，无法再其他文件中被调用。

不带参数的宏定义
    一个项目可以通过编译，链接最终形成一个可执行文件。
    每个源文件(.cpp)，但会单独编译，编译成一个目标文件(.o,也可能是.obj，扩展名跟操作系统有关)
    系统把这些.o文件进行链接，最终形成一个可执行文件。
    编译干了什么事？
        笼统的说：词法、语法分析、目标文件.o/.obj的生成，优化。
            1)预处理
                在源程序.cpp中加入一些特殊的代码（特殊命令），这些特殊代码有一些特殊的能力，提供一个特殊功能，
                    编译系统会先对这些特殊代码做处理，这个叫“预处理”。处理结果再和源程序代码一起进行下边的2）的编译,3)汇编这一系列操作。
                
                c语言提供三种预处理功能：1:宏定义 2：文件包含 3：条件编译 
                    这三种功能也是通过在程序代码中写代码来实现，这些代码比较特殊，都是以#开头。
            2)编译：词法，语法分析，目标代码生成，优化，产生一些临时文件。
            3)汇编:产生.o(.obj)目标文件。 

    不带参数的宏定义：用一个指定的标识符来代表一个字符串
        一般形式：#define  标识符   字符串     //标识符也叫宏名
            #define PI 3.1415926   //用PI来代替为3.1415926
        好处：
            1)用一个简单的名字代替一个长字符串，所以这个表示也被称为宏名，在预编译时将宏名替换成字符串的过程叫“宏展开”
                #define就是宏定义命令。 
            2)增加了修改方便性，为修改提供极大的便利，这种便利被频繁使用。这也叫提高了程序的可以移植性；
        说明： 
            1)宏名一般都用大写字母
            2)宏定义不是C语句，所以不必在行末加分号，如家加分号则连根号会被一起替换。
            3)#define命令出现在程序中函数的外面，宏名的有效范围时#define之后，到源文件结束，不能跨文件使用
            4)可以使用 #undef命令终止宏定义的作用域
            5)用#define进行宏定义时，还可以引用已经定义的宏，可以层层他置换
                #define PI 3.1415926
                #define DPI 2*PI
            6) 字符串的字符，即使与宏名相同，也不进行替换
    带参数的宏定义
    一般形式：#define   宏名（参数表）  字符串    //也是用右边 “字符串”代替 “宏名(参数表)“
        #define S(a,b) a*b
        int temp = S(2,3);    //把2,3分别代替宏定义中的形式参数a,b   ==>S(2,3)  ==> 2*3
                一般 “字符串中”都会包含参数表中指定的参数。 
                对一般形式中这个 “字符串”，如果字符串中有宏名后列出的参数比如(a,b) ,则将程序语句中相应的实参(常量，变量，表达式)代替形参，
                    如果字符串中的字符不是参数字符，则保留
                    #define PI  3.14
                    #define S(r)  PI*r*r
                    float area;
                    area = S(3,6);
        说明：  
            1)如果输入
                area = S(1+5);   //3.14 * 1+5*1+5 ,我们肯定希望的是3.14*(1+5)*(1+5)
                解决：在形式参数外面增加一个括号就行了  #define S(r) PI*(r)*(r)
            2)宏定义时宏名和带参数的括号之间不能加空格，否则，空格以后的字符都作为替代字符串的一部分了。
                #define S (r) PI *(r)*(r)    //S的后面不要加空格
            3)宏定义和函数的区别
                (1)函数调用时先求出参数表达式的值，然后带入形参，带参数的宏只进行简单的字符替换。并没有求表达式的值等行为发生。
                (2)函数调用时在程序运行时处理，分配临时内存。宏展开是在编译时进行的，展开时不分配内存，也没有返回值 这种说法。
                (3)宏的参数没有类型这个说法，只是个符号，展开时带入指定字符串中
                (4)使用宏次数多时，宏展开后源程序变长，函数调用不会是源程序变长；
                (5)宏替换只占用编译时间，不占用运行时间，而寒暑调用占的是运行时间（分配内存，传递参数，执行函数体，返回值）

                    宏替换复杂语句
                        #define MAX(x,y) (x) > (y)?(x):(y)
                    宏替换多行语句
                        #define MACROTEST do{\
                        printf("test\n");\
                        }while(0);

文件包含：将另外一个文件的内容包含到本文件中
    一般格式：  #include "文件名"
    #include 常用于#include其他.h文件中。.h文件称为头文件,h(head).常常把宏定义，函数说明，
            甚至一些其他的#include命令，以及其他一些全局变量的外部声明等等放在头文件中。

    说明：
        (1)很多公共修改都可以放到head.h中，一旦修改了这个.h文件，也就相当于修改了#include这个头文件的.cpp文件。
            那么这些.cpp文件系统会对其进行重新编译。
        (2)一个#include只能包含一个文件，如果要包含多个文件，那就要写多个#include
        (3)文件包含是可以嵌套的。一个头文件中还可以#include其他头文件。#include本质上就是把另外一个文件中的内容

条件编译
    条件编译的几种形式
    形式1：当标识符被定义过(#define)，则对程序段1进行编译，否则对程序段2进行编译。#else可以没有
    #ifdef 标识符
        程序段1(一堆代码)
    #else
        程序段2
    #endif

        #define DEBUG 1
        #ifdef DEBUG
            printf("something");
        #endif

    形式2：
    #ifndef 标识符
        程序段1(一堆代码)
    #else
        程序段2
    #endif

        #ifndef RELEASE
            printf("something");
        #endif

    形式3：当指定表达式值为正（非0）是就编译程序段2，我们事先给定一定的条件，就可以使程序在不用条件下事先不同的功能
    #if  表达式
        程序段1(一堆代码)
    #else
        程序段2
    #endif

        #define PI 3
        #if PI
            printf("PI is defined");
        #else 
            printf("PI is not defined");
        #endif

    条件编译的好处
    (1)条件编译可以减少生成的目标文件长度
    (2)跨平台问题为例增加程序的可移植性，增加程序的灵活性，我们就必须采用条件编译；

指针：
    一般占用 4个字节。
    指针变量中只存放地址
指向数组元素的指针变量的定义和赋值
    数组指针 是指 数组的开始地址，数组元素的指针就是数组元素的地址
        int a[5];   //只要是数组，内存地址一定是挨着的。
        int *p;   //指针变量，整形指针变量，和数组a类型相同。
        p = &a[0];  //把a[0]元素的地址赋给指针变量P,即p指向数组第0号元素；
        p = a;  //数组名代表数组的首地址 

    定义指针变量时也可以给指针变量赋予初值
        int *p = &a[0];

    通过指针应用数组元素
        int *p = a;
        *p = 19;    //a[0] = 19
        p = p+1;    //数组时以四个字节(int)为单位，所以加1价等同于在内存中加四

    p+i 或者 a+i 是什么意思
        假如现在p 指向数组首地址，a是数组名(代表数组首地址)，那么p+i或者a+i就是属主元素a[i]的地址，他们指向了数组a的第i个元素。
        结论：p+i 或者 a+i，都是地址，都可以赋给指针变量

    *(p+i) 或者 *(a+i)
        这两个是p+i或a+i所指向的数组元素，也就是a[i];

    p[i] 
        p[i] 与 *(p+i)等价，也就是跟a[i]等价
    
    举例：
        for(p = a ; p <(a+5);p++)
            printf("%d\n",*p);
        注意事项： 1)a++  //不能将数组名加加

数组名作为函数参数
    如果一个参数的数组，想在函数中改变词数组的元素的值，实参和形参的对应关系可以有4种。
        1)实参和形参都是数组名
            int a[5];

            changevalue(a)
            void changevalue(int b[]){}

         2)实参用数组名，形参用指针变量
            int a[5];

            changevalue(a)
            void changevalue(int *p){}
        
        3)实参和形参都用指针变量
            int a[5];
            int *pa= a
            changevalue(pa)
            void changevalue(int *p){} 

        4)实参为指针，形参为数组名；把指针传递给数组名，那这个数组名就相当于这个数组的首地址。
            int a[5];
            int *pa= a
            changevalue(pa)
            void changevalue(int b[]){} 

指向多维数组的指针和指针变量探究
    int a[3][4]   //数组名a 同样代表数组的首地址

    1）二维数组名，也是整个二维数组的首地址
        int a[3][4];
        int *p;
        p = (int *)a;

    2)a+1,a+2 分别代表第一行首地址 和第二行首地址。所以a+1跳过16个字节的。
    p = (int *)(a+1);
    p = (int *)(a+2);

    3)这表示a[0],a[1],a[2]是一维数组名。c语言规定数组名代表数组的首地址，所以就有如下:
        a[0] == &a[0][0]    //是第0行的首地址
        a[1] == &a[1][0]    //是第1行的首地址
        a[2] == &a[2][0]    //是第2行的首地址

        int *p = a[0];
        int *p = a[1];

    4)第0行第1列元素怎么表示
        &a[0][1]   a[0] + 1
        int &a[0][1];
        p = a[0] + 1

    5)a[0]等价于 *a
      a[0] + 1 等价于 *a+1,等价于 &a[0][1] 
      a[1] 等价于 *(a+1)
      a[1] + 2  等价于 *(a+1) +2,等价于 &a[1][2]

    6)a[0] + 1 等价于 *a+1,等价于 &a[0][1]    这些都是地址
      *(a[0] + 1) 就代表 a[0][1]  *(*a+1)也是 a[0][1]的值
      也有：*(a[1] + 2), a[1][2]的值 ，*(*(a+1) + 2)  都表示1行第2列元素值。

    7)
      a[1]的性质问题：
        a[i]和&a[i]地址值是一样的

指针数组和数组指针：
    指针数组：
        int *p[10];   //首先这是个数组，数组中有10个元素，每个元素都是个指针，相当于定义了10个指针变量。
    
    数组指针：
        int (*p)[10];  //这是一个指针变量，这个指针变量用来指向含有10个元素的一维数组。 
        int a[10];
        int i ,j;
        for(i=0;i<10;i++)
        {
            a[i] = i;
        }
        p = &a  //注意这里要用&地址符，否则编译器报错。  其实 &a和a其实值应该相等

        int *q;
        q = (int *)p;
        for(i=0;i<10;i++)
        {
            printf("value = %d\n",*q);
            q++;
        } 


        int (*p)[10];
        int a[3][10];
        int i ,j;
        for(i = 0;i < 3;i++)
        {
            for(j=0;j<10;j++)
            {
                a[i][j] = i+j;
            }
        }
        p = a;  //二维数组名可以直接复制给数组指针
        int *q;
        q = (int *)p;
        for(i=0;i<3;i++)
        {
            q = *(p+1);   //每次指向一个新行
            for(j=0;j<10;j++)
            {
                printf("%d ",*q)
                q++
            }
            printf("-------------\n");
            //p++;    //跳40个字节 
            //q = (int *)p;
        }

多维数组指针做函数参数：
    略

字符串表达形式
    char mystr1[] = "I love China！"   //拷贝
    char mystr2[] = "I love China!"    //拷贝
    printf("%s\n",mystr1);
    printf("%s\n",mystr2);

    char *pmystr1 = "I love China!";  //不是拷贝，本行相当于把内存中这个字符串常量的首地址赋给了指针变量pmystr1
    cahr *pmystr2 = "I love China!";  //字符串常量的首地址赋给了指针变量pmystr2
                pmystr1的地址等于pmystr2
    C语言中对字符串常量有特殊的处理：在内存中开辟出一段类似字符串数组的东西存放字符串常量。
    所以 "I love China！"是存在于内存之中，并且有一个内存地址。

    char a[] = "I love China!";
    char b[100];   //保证比a字符串长
    int i ;
    for(i=0;*(a+i) != '\0';i++)  //*(a+i) 相当于 a[i]
    {
        *(b+i) = *(a+i);     
    }
    *(b+i) = '\0';
    printf("string a is %s\n",a);
    printf("string b is %s\n",b);


    char a[] = "I love China!";
    char b[100];   //保证比a字符串长
    int i ;
    p1 = a;
    p2 = b;
    for(;p1 !='\0';p1++,p2++)   //刚开始循环时， p1指向a[0],也就是 p1 = &a[0]
    {
        *p2 = *p1;     //b[0] = a[0];
    }    
    *p2 = '\0';
    printf("string a is %s\n",a);
    printf("string b is %s\n",b);

字符串指针做函数参数
        void copystr(char from[],char to[])
        //void copystr(char *from,char *to)
        {
            int i=0;
            while(from[i] != '\0')
            {
                to[i] = from[i];   //逐个字符串拷贝，必须保证to比from大
                i++;
            }
            to[i] = '\0';
        }

        {         //使用for循环也可以很好的实现
            for(;*from != '\0';from++,to++)
            {
                *to = *from;
            }
            *to = '\0';
        }

        {    //用while循环实现
            while(*from)
                *to++ = *from++
        }
            *to='\0';  

字符指针变量与字符数组
    1)字符数组由若干个元素组成，每个元素中存放一个字符，而字符指针变量中存放的是字符串的首地址。仅仅是首地址！！
            千万不要理解成字符内容存放到字符指针变量中
    2)赋值方式:
        char str[100] = "I love China!"  //定义时初始化，相当于拷贝字符串内容到str中
        char str[100];
        str = "I love China!";   //绝对不行      "I love China!" ==>是一个常量

        char *a ;
        a =  "I love China!";    // "I love China!"是字符常量，在内存中是有固定地址的，这里只是让字符指针a指向这个地址而已。

    3)指针变量的值可以改变
        char *a =  "I love China!";
        a = a +7;
        printf("%s\n",a)   //China!

        char a[] = "I love China!";
        a= a + 7;   //数组首地址是不可以改变的

用函数指针变量调用函数
    1)一个函数在编译的时候，系统会给这个函数分配一个入口地址，这个入口地址称为函数的指针。
        既然有地址，就可以定义一个指针变量指向该函数，然后就可以通过该指针变量调用该函数了。 
    2)每个函数在执行文件时都会占用一段内存单元，它们有一个起始地址。可以通过指针变量指向这个其实地址
    int max(int x,int y)
    {
        if(x>y)
            return x;
        return y;
    }

    int c;
    int (*p)(int x,int y);   //定义一个函数指针变量
                            //不可以写成 int *p(int x,int y);  这就称为函数声明，这里的int *就表示这个函数的返回值是指向整形变量的指针。
                            //(*p)的括号不能省略，有()表示*和p先结合代表一个指针变量。然后在和后边的()结合表示此指针变量指向函数
                            //int(*p)(int x,int y);  可以写成 int (*p)(int ,int );
    p = max; //将函数max的入口地址赋给指针变量p，函数名代表函数的入口地址。
                //现在p就是指向函数max的指针变量，p和max都指向函数的开头
                //p = &max，这样写也可以  
    c = (*p)(5,9);   //调用*p，就是调用函数max。p指向函数max的入口，等价于 c=max(5,19)
                        //这里的调用只是用*p取代了函数名max
                        //p不能指向函数的中间某条语句，所以*(p+1)不合法
                        //其实这个 * 是可以省略的：所以在这里 c= (*p)(5,19);  和 c = p(5,19);  等价
    总结:
        1)函数指针变量定义的一般形式：
            数据类型表示符  (*指针变量名)(形参列表);
            其中，“数据类型表示符”，就是数据类型，“形参列表” 里可以只有类型说明符，多个类型说明符之间用逗号分隔。
                可以通过函数指针指向不同的函数，来达到调用不同函数的目的；这个是有实际用途的。

        2)函数的调用，可以通过函数名，也可以通过函数指针调用

        3)对指向函数的指针变量p,不可以做 p++,p-- 之类的运算。

把指向函数的指针变量作为函数参数
    指向函数的指针变量也可以作为另外一个函数的参数 ，从而实现在另外一个函数中调用该函数指针变量所指向的函数的目的

    int max(int x,int y)
    {
        if(x>y)
            return x;
        return y;
    }

    int wwmax(int x,int y,int (*midfunc)(int ,int))  //形参就是一个函数指针
    {
        int result = midfunc(x,y);   //调用函数指针midfunc所指向的函数
        return result;
    } 

    int c;
    c = wwmax(5,19,max);
    printf("c=%d\n",c);   

    int(*p)(int ,int );   //定义一个函数指针变量；
    p = max;
    c = wwmax(45,29,p)
    printf("c=%d\n",c);   

返回指针值的函数
    函数中也可以返回指针型数据。也就是地址
    
    返回指针得函数的一般定义形式：
        数据类型 *函数名 (参数列表)
            int *a(int x,int y);    -->a 函数名 ()优先级高于*，因此 a先和()结合，这就是函数形式，返回值为整形指针

    int sum  //把sum定义成全局变量就可以解决问题
    int *add(itn x,int y)
    {
        int sum =x +y;
        return &sum    //隐含一个致命的问题，add函数调用完毕后sum的内存会被系统回收；
                            //绝对不可以吧sum的内存地址返回到被调用函数中并加以使用
    }

    int *presult;
    presult = add(4,5);   //执行add后，presult指向的内存已经被释放，不应该在从此内存中获得值。
    printf("和值为%d\n",*presult);

指针数组
    char *pName[] = {"c++","JAVA","GO","CSharp"};
    int isl = sizeof(pName);   //每个指针变量占4个字节，有5个元素，所以一共就占20个字节。
    int isize = isl / sizeof(pName[0]);   //  20/5 表示pName中有5个元素，pName能引用的下标就是[0]--[4] 

    char *p2 = "JAVA";   //把字符串的首地址给指针 
        由此可得：p2的地址和pName[1]的地址是相同的

    for(i=0;i<isize;i++)
    {
        printf("pName[%d] = %s\n",i,pName[i]);
    }
    printf("----------------\n");

    char *ptemp;
    ptemp = pName[0];  //ptemp指向了"c++";
    pName[0] = pName[1];  //pName[0]指向了 "JAVA"
    pName[1] = ptemp;   //pName[1]指向了c++ 

指向指针的指针：用来指向指针变量的变量，简称指向指针的指针 
    char **p;   //定义了一个指向 字符串指针变量的指针变量
    int **p;   //定义了一个指向整型指针变量的指针变量

    char **pp;  //定义了一个指向指针的指针
    pp = &pName[0];   //*pp就是pp所指向的指针，也就是pName[0];
    printf("pp = %s",*pp);
    printf("--------------\n");

    int abc = 5;
    int *pabc = &abc;  //指向整形数据的指针
    int **ppabc = &pabc;  //指向指针的指针
    printf("abc = %d\n",abc);
    printf("abc = %d\n",*pabc);
    printf("abc = %d\n",**ppabc);  

指针数组做main函数形参

    int main(
        int argc,    //整型  ，应该是argv指针数组的元素个数
        char *argv[]   //就是这个指针数组，argv[0]保存的是当前可执行文件的完整路径名
    )

指针变量可以为空值，表示不指向任何变量
    int *p = NULL;  //NULL就是整数0，就是使p不指向任何变量

void *型指针：万能型指针变量，也就是能够指向任意数据类型
    int a =3;
    int *p = &a;

    float bf = 56.f;
    float *pf = &bf;

    void *pwn = NULL;

    pwn = p;
    pwn = f;

    pf = (float *)pwn;

共用体：又叫联合
    把几种不同类型的变量存放到同一段内存单元(同一个内存地址开始的单元中)。
    几个变量共同占同一段内存的结构，就叫共用体；
    定义形式：
        union  共用体名
        {
            成员列表
        }变量列表;
    
    union  myuni
    {
        int carnum;   //轿车编号，4个字节
        char cartype;  //轿车的类型，
        char cnae[60];
    }a,b,c;  //将共用体的定义和变量定义放在一起

    union myuni a,b,c;   //将共用体变量和共用体的定义分开

    结构体和共用体明显不同
        结构体变量占的内存是各个成员的内存长度之和；
        共用体所占的内存长度等于最长的成员长度，而不是每个成员长度加起来

    说明：
        1)共用体变量的引用
            a.cname;
            a.carnum;
        2)共用体变量的特点
            同一段内存存放集中不同类型的成员，但每个瞬间只能存放其中一种，每个瞬间只能有一个成员起作用，
                    其他成员不起作用，并不是同时都存在和都起作用。程序代码中最后给哪个成员赋值，哪个成员就起作用
            a.carnum = 123123113;
            strcpy(a.cname,"ab");   //此时内存中存储的是 a.cname 的值
        3)共用体变量的地址 和 其成员的地址都相同；
           &a,&a.carnum,&a.cartype,&a.cname

        4)共用体变量不能在定义的时候初始化(只能初始化第一个)
            union myuni aa = {12};
          
        5)不能把共用体变量作为函数参数，也不能让函数带回共用体变量。

枚举类型
    四种颜色：红 绿 蓝 黄
    RED 表红 ，GREEN表绿 BLUE蓝 YELLOW黄
    
    enum color
    {
            RED,  //枚举常量（当成一个整型数字 ，看成整型常量，占四个字节）
            GREEN,
            BLUE,
            YELLOW
    }

    enum color mycolor1,mycolor2;   //定义了2个枚举类型变量

    说明：
        1)枚举：就是将值一一列举出来，那么mycolor1和mycolor2变量的值只限于列出来的这些值的范围内。
        2)可以直接定义枚举变量，不要枚举名，这就要直接定义枚举变量才行了。 
        3)这些RED, GREEN,BLUE,YELLOW 这些叫枚举常量，值不能被改变
        4)可以直接给枚举型变量赋值；
            mycolor1 = YELLOW
            mycolor2 = RED;
        5)定义枚举类型时，可以改变枚举常量的值
        6)枚举值，就可以理解成整型值
        7)枚举值可以赋给一个整型 
        int abc;
        abc = GREEN;

用typedef 来定义类型
    int ,char ,float,double,结构体，共用体，枚举类型.
    我们可以用 typedef 来定义新的类型名，来代替已有的类型名；
    typedef int INTEGER;   //可以用INTEGER代表int，再定义整型变量时我们就可以如下定义。
    INTEGER a,b,c,   //定义了三个整型变量

    //如何定义结构体类型
    typedef struct date
    {
        int month;
        int day;
        int year;
    }DATE;
    DATE birthday;   //定义一个结构体变量
    DATE *p;   //P为指向此结构体类型数据的指针

    变形，多记
    typedef int NUM[100];  //定义NUM为整形数组类型  
    NUM n;   //等价于 int n[100]

    typedef char *PSIRING;   //定义PSIRING为字符指针类型 typedef char *PSIRING;
    PSIRING p,q;  //char *p,*q

    typedef int (*P0INTER)();   //定义P0INTER未知项函数的指针类型，该函数返回的是整型值
    P0INTER p1,p2;

    总结：typedef这种语句怎么写，一定义一个整型数组为例：
        第一步：先写出常规的整形数组定义方法
            int n[100];
        第二部：将变量名n替换成自己想用的类型名
            int NUM[100];
        第三部:在前面加上typedef
            typedef int NUM[100]
            NUM a,b,c,d;

    说明:
        a)typedef中用的类型别名一般都大写；
        b)typedef用来定义类型名，不是用来定义变量的；
        c)typedef只是对已经存在的类型增加一个类型名，并没有创造新类型
        d)typedef是编译的时候处理的；
        e)typedef 主要作用：程序的通用性和可移植性.
             int a,b,c;
             typedef int INTEGER;
             INTEGER a,b,c;

             typedef __int64 INTEGER; 

位的概念：
    一个int型数据占四个字节内存，一个char型数据占1个字节内存


位运算的一个具体范例
    需求：记录这10个任务是否完成。没完成，用0标记。完成了，用1标记。

    针对这个问题，有两个前提条件：
        (1)每日任务有10个
        (2)我们只需要记录该任务是否完成，0表示没完成，1表示完成，只有这两个状态

    unsigned int task;   //4个字节，代表32位二进制数，每个二进制位又可以是0或者1。
                            //可以用一个unsigned int 变量，记录多大32种状态，每个状态要么是0，要么是1；
                        //一个unsigned int 是32位，最右边是第一个位，逐步往左边来，最左边代表第32位置。
    要写那些功能代码呢？
        (1)判断某个任务是否做完
        (2)标记某个任务做完了

        #define BIT(x)  (1<<(x))   //这段代码日后写程序时很可能要用到
                                   //代码里 BIT(0)    <====> (1<<(0))  //1左移0位
                                   //代码里 BIT(1)    <====> (1<<(1))  //1左移1位
                                   //代码里 BIT(2)    <====> (1<<(2))  //1左移2 位
                                   //左移一位，相当于*2，所以 BIT(0) = 1;BIT(1)=1*2=2;BIT(3)=2*2=4; ....;
    int i;
    for(int i=0;i<10;i++)
    {
        printf("BIT(%d) = %d\n",i,BIT(i));
    }


    按位与&:如果两个相应的为都为1，则按位与的结果为1，否则为0；全1则出1，有0则出0
    想提取第7位，那么只需要 task &1000000
    这个结果就是：
        如果task中（一共32位），的第7位是0的话，那么task& 1000000 = 0;
        如果task第7位为1的话，那么task & 1000000 = 64 = BIT(6) 不等于0; 

    10个任务
    enum EnumTask
    {
        ETask1 = BIT(0),   //1   =1
        ETask2 = BIT(1),   //2   =10
        ETask3 = BIT(2),   //4   =100
        ETask4 = BIT(3),   //8   =1000
        ETask5 = BIT(4),   //16  =10000
        ETask6 = BIT(5),   //32  =100000
        ETask7 = BIT(6),   //64  =1000000
        ETask8 = BIT(7),   //128 =10000000
        ETask9 = BIT(8),   //256 =100000000
        ETask10 = BIT(9),  //512 =1000000000
    };

    unsigned int task=0;  //刚开始所有任务都没执行过，把玩家挡圈完成的任务标记设置为0
                //判断第七个任务是否执行过
    if(task & ETask7) //按位与，不为0，则表示任务7做过
    {
        //任务7已经做过
        printf("任务7已经做过了");
    }
    else{
        //任务7还没做过
        printf("任务7还没做过做过了");
        task = task | ETask7;   //把任务做完了；  注意：为操作运算符，优先级高于 = q
    }

    按位或 | 运算符: 参加运算的两个运算量，如果两个相应的位有一个为1，则该结果为1，否则为0；全0出0，有1出1。
    如果我们把task跟1000000做一个按位或运算，会出现啥结果: 结果就是task的其他位都不变，但是第7位肯定会变成1(不管你原来是啥）。
        把第七位设置为1，就起到了标记任务7做完了的目的。

文件概述：
    文件：看成字符串序列(字符流)

    人类：根据数据组织形式，我们把文件分成两种：ASCII文件(文本文件)，二进制文件。--对于计算机来讲，都是二进制文件。
        1)ASCII文件(文本文件),每个字节，存放一个ASCII码，代表一个字符，这种文件一般打开就能看懂里边的内容
        2)二进制文件:把内存中的数据按照其在内存中的存储形式原样输出到磁盘上存放。   

        //对文本文件的理解:
            文件对于计算机来讲，计算机不会管你是二进制文件还是文本文件，对于计算机，都是二进制数据 
                但是往文件中写入内容，你可以选择是以文本形式写入，还是以二进制形式写入。
            或者，打开文件往外读内容也一样:可以选择以文本形式打开读或者以二进制形式打开文件读。

        //人类理解中的二进制数据
        short int a;   //占2个字节
        int ilen  = sizeof(a);
        a = 10000;

        //大端存储(低的存高地址，高的存低地址) 和 小端存储(低的存低地址，高的存高地址)

            //低字节 0x10 存放在了低地址
            //高字节 0x27 存放在了搞地质        小端存储

        //文本文件和二进制文件区别
            (1)不管啥文件，对于计算机来讲，他就是字节流
            (2)九三级并不区分你是文本文件还是二进制文件，人类才区分这个

文件的打开
    文件在读或者写之前，必须要打开，读写结束之后，必须要关系，否则会造成文件内容不完整或者资源泄漏
    fopen:文件打开函数 ，fopen函数的调用方式
    FILE *fp;    FILE是个结构，fp是指向结构FILE的指针变量(结构体指针);
    fp = fopen(文件名，使用的文件的方式);  //文件名和使用文件的方式 都是字符串
    fp = fopen("a.txt","r");  //打开a.txt文件，使用的打开方式为只读，fp现在就指向了我们打开的a.txt文件。
                                //sizeof(FILE);
    if(fp ==NULL)
    {
        文件打开失败
    }
    //通过fopen语句告诉了系统三个信息:
        (1)我们需要打开的文件名
        (2)使用文件的方式
        (3)让那个指针变量指向被打开的文件。这里是fp 这是一个指针变量，这个指针变量用来指向含有10个元素的一维数组。

    //文件有个位置指针fgetc

文件的关闭：只有fopen成功的文件才需要关闭。
    关闭文件的原因
        (1)释放该文件占用的内存单元；要养成资源用完及时释放的好习惯。
        (2)防止往文件中写内容时文件内容写入不全，关闭文件
    文件关闭函数的一般形式
    fclose(文件指针);
    if(fp != NULL)
    {
        fclose(fp);   //fp就是fopen()的返回值
    }

文件的读写简单讲
    fputc 和 fgetc函数
    fputc(): 该函数把一个字符写到磁盘文件上去，一般形式为:
    fputc(ch,fp);   //ch就是这个字符，如果fputc函数失败，会返回EOF，如果成功，则返回值就是写入文件的那个字符的ascii码值
                        //EOF (End of file)  //#define EOF (-1)

        #include<stdio.h>
        int main()
        {
            FILE* fp;
            fp = fopen("FTest.txt", "w");
            if (fp == NULL)
            {
                printf("文件打开失败");
            }
            else
            {
                printf("文件打开成功");
                char reco = fputc('a', fp);
                if (reco == EOF)    
                {
                    printf("文件写入失败");
                }
                fclose(fp);
            }
            return 0;
        }

    fgetc:从指定文件读取一个字符 
        调用形式：char reco = fgetc(fp);
        如果执行成功，返回读入的中字符，如果读取失败，或者整个文件读到末尾，则返回EOF。
            fp = fopen("FTest.txt", "r");  //文件刚刚打开，文件位置位于文件头部
            if (fp == NULL)
            {
                printf("文件打开失败");
            }
            else
            {
                char reco = fgetc(fp);   //没读出一个字符，文件指针自动向下走一个字符；
                while (reco != EOF)
                {
                    putchar(reco);   //往屏幕输出一个字符
                    reco = fgetc(fp);
                } 
                printf("\n");
                fclose(fp);
            }
    feof(fp):   //文件是否读结束。如果文件结束的话,feof(fp);返回1(真)，如果文件没有结束,feof(fp)返回0(假)

四:文件读写实战操练
    商业级代码；非常严谨


将结构体写入二进制文件
    fwrite:用于向文件中写入数据
        一般形式: fwrite(buffer,size,count,fp);
        buffer:指针/地址,要写到文件中的数据就在这个地址里保存着
        size:要写入文件的字节数
        count:要写入多少个size字节的数据项
        fp:文件指针
        返回值：如果fwrite失败，则返回0，否则返回count值；

        #include<stdio.h>
        struct stu {
            char name[30];
            int age;
            double score;
        };
        int main()
        {

            struct stu student[2];   //2个元素的结构体数组
            strcpy(student[0].name, "张三abc");
            student[0].age = 21;
            student[0].score = 92.1f;

            strcpy(student[1].name, "李四abc");
            student[1].age = 19;
            student[1].score = 86.2f;

            FILE* fp;
            fp = fopen("structfile.bin", "wb");
            if (fp == NULL)
            {
                printf("打开文件失败");
            }
            else {
                //打开文件成功
                int result = fwrite(student, sizeof(struct stu), 2, fp);
                fclose(fp);
            }
            return 0;
        }

            注意事项:
            (1)往文件里写的结构体 中 不要出现指针类型变量
            (2)结构体内存对齐问题，和编译器有关；  

            2个解决变法：
                (1)不要跨平台
                (2)强制无论在什么平台，都是1字节最气(不用对齐)，是43字节就是42 
                        #pragna pack(1)
                        struct stu {
                            char name[30];
                            int age;
                            double score;
                        };
                        #pragna pack()

从二进制文件中读出结构体数据
   fread:用于向文件中写入数据
        一般形式: fread  (buffer,size,count,fp);
        buffer:指针/地址,从文件中读出来的数据写到哪个地址去呢,就是这个地址
        size:要读入的字节数
        count:要读入 多少个size字节的数据项
        fp:文件指针
        返回值：如果fread失败，则返回0，否则返回count值；

        fp = fopen("structfile.bin", "rb");
        if (fp == NULL)
        {
            printf("打开文件失败");
        } 
        else
        {
            //打开文件成功
            struct stu studentnew[2];
            int result = fread(studentnew,sizeof(struct stu),2,fp);
            fclose(fp);
        }
